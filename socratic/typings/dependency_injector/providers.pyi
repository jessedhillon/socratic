from __future__ import annotations

import typing as t
from pathlib import Path
from typing import (
    Type,
    Optional,
)

import yaml
import pydantic_settings

import dependency_injector.resources as resources

Injection = t.Any
ProviderParent = "Provider[t.Any]" | t.Any
T = t.TypeVar("T")
TT = t.TypeVar("TT")
P = t.TypeVar("P", bound="Provider[t.Any]")
BS = t.TypeVar("BS", bound="BaseSingleton[t.Any]")

class Provider(t.Generic[T]):
    def __init__(self) -> None: ...

    # WARN technically, __call__ should have return type T | t.Awaitable[T] but
    #      that'll make things quite annoying
    def __call__(self, *args: Injection, **kwargs: Injection) -> T: ...
    def async_(self, *args: Injection, **kwargs: Injection) -> t.Awaitable[T]: ...

    def __deepcopy__(self, memo: Optional[dict[t.Any, t.Any]]) -> Provider[T]: ...
    def __str__(self) -> str: ...
    def __repr__(self) -> str: ...
    @property
    def overridden(self) -> tuple[Provider[T]]: ...
    @property
    def last_overriding(self) -> Provider[T | None]: ...

    def override(self, provider: Provider[T] | t.Any) -> OverridingContext[Provider[T]]: ...
    def reset_last_overriding(self) -> None: ...
    def reset_override(self) -> None: ...
    @property
    def overrides(self) -> tuple[Provider[T], ...]: ...
    def register_overrides(self, provider: Provider[T] | t.Any) -> None: ...
    def unregister_overrides(self, provider: Provider[T] | t.Any) -> None: ...
    def delegate(self) -> Provider[T]: ...
    @property
    def provider(self) -> Provider[T]: ...
    @property
    def provided(self) -> ProvidedInstance: ...
    def enable_async_mode(self) -> None: ...
    def disable_async_mode(self) -> None: ...
    def reset_async_mode(self) -> None: ...
    def is_async_mode_enabled(self) -> bool: ...
    def is_async_mode_disabled(self) -> bool: ...
    def is_async_mode_undefined(self) -> bool: ...
    @property
    def related(self) -> t.Iterator[Provider[T]]: ...
    def traverse(self, types: Optional[t.Iterable[Type[TT]]] = None) -> t.Iterator[TT]: ...
    def _copy_overridings(self, copied: Provider[T], memo: Optional[dict[t.Any, t.Any]]) -> None: ...

class Object(Provider[T]):
    def __init__(self, provides: T | None = None) -> None: ...
    @property
    def provides(self) -> T | None: ...
    def set_provides(self, provides: T | None) -> Object[T | None]: ...

class Self(Provider[T]):
    def __init__(self, container: T | None = None) -> None: ...
    def set_container(self, container: T) -> None: ...
    def set_alt_names(self, alt_names: t.Iterable[t.Any]) -> None: ...
    @property
    def alt_names(self) -> tuple[t.Any]: ...

class Delegate(Provider[Provider[T]]):
    def __init__(self, provides: Provider[T] | None = None) -> None: ...
    @property
    def provides(self) -> Provider[T] | None: ...
    def set_provides(self, provides: Provider[T] | None) -> Delegate[T]: ...

class Aggregate(Provider[T]):
    def __init__(self, provider_dict: Optional[dict[t.Any, Provider[T]]] = None, **provider_kwargs: Provider[T]) -> None: ...  # noqa: E501
    def __getattr__(self, provider_name: t.Any) -> Provider[T]: ...

    def __call__(self, provider_name: t.Any | None = None, *args: Injection, **kwargs: Injection) -> T: ...
    def async_(self, provider_name: t.Any | None = None, *args: Injection, **kwargs: Injection) -> t.Awaitable[T]: ...

    @property
    def providers(self) -> dict[t.Any, Provider[T]]: ...
    def set_providers(self, provider_dict: dict[t.Any, Provider[T]] | None = None, **provider_kwargs: Provider[T]) -> Aggregate[T]: ...  # noqa: E501

class Dependency(Provider[T]):
    def __init__(self, instance_of: Type[T] = object, default: (Provider[T] | T) | None = None) -> None: ...
    def __getattr__(self, name: str) -> t.Any: ...

    @property
    def instance_of(self) -> Type[T]: ...
    def set_instance_of(self, instance_of: Type[T]) -> Dependency[T]: ...

    @property
    def default(self) -> Provider[T]: ...
    def set_default(self, default: (Provider[T] | T) | None = None) -> Dependency[T]: ...

    @property
    def is_defined(self) -> bool: ...
    def provided_by(self, provider: Provider[T]) -> OverridingContext[Provider[T]]: ...
    @property
    def parent(self) -> ProviderParent | None: ...
    @property
    def parent_name(self) -> str | None: ...
    def assign_parent(self, parent: ProviderParent) -> None: ...

class ExternalDependency(Dependency[T]): ...

class DependenciesContainer(Object[T]):
    def __init__(self, **dependencies: Provider[T]) -> None: ...
    def __getattr__(self, name: str) -> Provider[T]: ...
    @property
    def providers(self) -> dict[str, Provider[T]]: ...
    def resolve_provider_name(self, provider: Provider[T]) -> str: ...
    @property
    def parent(self) -> ProviderParent | None: ...
    @property
    def parent_name(self) -> str | None: ...
    def assign_parent(self, parent: ProviderParent) -> None: ...

class Callable(Provider[T]):
    def __init__(self, provides: Optional[t.Callable[..., T] | str] = None, *args: Injection, **kwargs: Injection) -> None: ...  # noqa: E501
    @property
    def provides(self) -> t.Callable[..., T] | None: ...
    def set_provides(self, provides: (t.Callable[..., T] | str) | None) -> Callable[T]: ...
    @property
    def args(self) -> tuple[Injection]: ...
    def add_args(self, *args: Injection) -> Callable[T]: ...
    def set_args(self, *args: Injection) -> Callable[T]: ...
    def clear_args(self) -> Callable[T]: ...
    @property
    def kwargs(self) -> dict[t.Any, Injection]: ...
    def add_kwargs(self, **kwargs: Injection) -> Callable[T]: ...
    def set_kwargs(self, **kwargs: Injection) -> Callable[T]: ...
    def clear_kwargs(self) -> Callable[T]: ...

class DelegatedCallable(Callable[T]): ...

TCallable = t.TypeVar('TCallable', bound=t.Callable[..., t.Any])
class AbstractCallable(t.Generic[TCallable]):
    def override(self, provider: TCallable) -> OverridingContext[Provider[TCallable]]: ...

class CallableDelegate(Delegate[T]):
    def __init__(self, callable: t.Callable[[t.Any], T]) -> None: ...

class Coroutine(Callable[T]): ...

class DelegatedCoroutine(Coroutine[T]): ...

TCoroutine = t.TypeVar('TCoroutine', bound=t.Coroutine[t.Any, t.Any, t.Any])
class AbstractCoroutine(t.Generic[TCoroutine]):
    def override(self, provider: TCoroutine) -> OverridingContext[Provider[TCoroutine]]: ...

class CoroutineDelegate(Delegate):
    def __init__(self, coroutine: Coroutine) -> None: ...

class ConfigurationOption(Provider[t.Any]):
    UNDEFINED: object
    def __init__(self, name: tuple[str], root: Configuration) -> None: ...
    def __enter__(self) -> ConfigurationOption: ...
    def __exit__(self, *exc_info: t.Any) -> None: ...
    def __getattr__(self, item: str) -> ConfigurationOption: ...
    def __getitem__(self, item: str | Provider) -> ConfigurationOption: ...
    @property
    def root(self) -> Configuration: ...
    def get_name(self) -> str: ...
    def get_name_segments(self) -> tuple[str | Provider]: ...
    def as_int(self) -> TypedConfigurationOption[int]: ...
    def as_float(self) -> TypedConfigurationOption[float]: ...
    def as_(self, callback: t.Callable[..., T], *args: Injection, **kwargs: Injection) -> TypedConfigurationOption[T]: ...
    def required(self) -> ConfigurationOption: ...
    def is_required(self) -> bool: ...
    def update(self, value: t.Any) -> None: ...
    def from_ini(self, filepath: Path | str, required: bool = False, envs_required: bool = False) -> None: ...
    def from_yaml(self, filepath: Path | str, required: bool = False, loader: t.Any | None = None, envs_required: bool = False) -> None: ...
    def from_json(self, filepath: Path | str, required: bool = False, envs_required: bool = False) -> None: ...
    def from_pydantic(self, settings: pydantic_settings.BaseSettings, required: bool = False, **kwargs: t.Any) -> None: ...
    def from_dict(self, options: dict[str, t.Any], required: bool = False) -> None: ...
    def from_env(self, name: str, default: t.Any | None = None, required: bool = False, as_: Optional[t.Callable[..., t.Any]] = None) -> None: ...
    def from_value(self, value: t.Any) -> None: ...

class TypedConfigurationOption(Callable[T]):
    @property
    def option(self) -> ConfigurationOption: ...

class Configuration(Object[t.Any]):
    DEFAULT_NAME: str = "config"
    def __init__(
            self,
            name: str = DEFAULT_NAME,
            default: t.Any | None = None,
            *,
            strict: bool = False,
            ini_files: Optional[t.Iterable[Path | str]] = None,
            yaml_files: Optional[t.Iterable[Path | str]] = None,
            json_files: Optional[t.Iterable[Path | str]] = None,
            pydantic_settings: Optional[t.Iterable[pydantic_settings.BaseSettings]] = None,
    ) -> None: ...
    def __enter__(self) -> Configuration : ...
    def __exit__(self, *exc_info: t.Any) -> None: ...
    def __getattr__(self, item: str) -> ConfigurationOption: ...
    def __getitem__(self, item: str | Provider) -> ConfigurationOption: ...

    def get_name(self) -> str: ...
    def set_name(self, name: str) -> Configuration: ...

    def get_default(self) -> dict[t.Any, t.Any]: ...
    def set_default(self, default: dict[t.Any, t.Any]): ...

    def get_strict(self) -> bool: ...
    def set_strict(self, strict: bool) -> Configuration: ...

    def get_children(self) -> dict[str, ConfigurationOption]: ...
    def set_children(self, children: dict[str, ConfigurationOption]) -> Configuration: ...

    def get_ini_files(self) -> list[Path | str]: ...
    def set_ini_files(self, files: t.Iterable[Path | str]) -> Configuration: ...

    def get_yaml_files(self) -> list[Path | str]: ...
    def set_yaml_files(self, files: t.Iterable[Path | str]) -> Configuration: ...

    def get_json_files(self) -> list[Path | str]: ...
    def set_json_files(self, files: t.Iterable[Path | str]) -> Configuration: ...

    def get_pydantic_settings(self) -> list[pydantic_settings.BaseSettings]: ...
    def set_pydantic_settings(self, settings: t.Iterable[pydantic_settings.BaseSettings]) -> Configuration: ...

    def load(self, required: bool = False, envs_required: bool = False) -> None: ...

    def get(self, selector: str) -> t.Any: ...
    def set(self, selector: str, value: t.Any) -> OverridingContext[P]: ...
    def reset_cache(self) -> None: ...
    def update(self, value: t.Any) -> None: ...
    def from_ini(self, filepath: Path | str, required: bool = False, envs_required: bool = False) -> None: ...
    def from_yaml(self, filepath: Path | str, required: bool = False, loader: t.Any | None = None, envs_required: bool = False) -> None: ...
    def from_json(self, filepath: Path | str, required: bool = False, envs_required: bool = False) -> None: ...
    def from_pydantic(self, settings: pydantic_settings.BaseSettings, required: bool = False, **kwargs: t.Any) -> None: ...
    def from_dict(self, options: dict[str, t.Any], required: bool = False) -> None: ...
    def from_env(self, name: str, default: t.Any | None = None, required: bool = False, as_: Optional[t.Callable[..., t.Any]] = None) -> None: ...
    def from_value(self, value: t.Any) -> None: ...

class Factory(Provider[T]):
    provided_type: Type | None
    def __init__(self, provides: (t.Callable[..., T] | str) | None = None, *args: Injection, **kwargs: Injection) -> None: ...
    @property
    def cls(self) -> Type[T]: ...
    @property
    def provides(self) -> Optional[t.Callable[..., T]]: ...
    def set_provides(self, provides: (t.Callable[..., T] | str) | None) -> Factory[T]: ...
    @property
    def args(self) -> tuple[Injection]: ...
    def add_args(self, *args: Injection) -> Factory[T]: ...
    def set_args(self, *args: Injection) -> Factory[T]: ...
    def clear_args(self) -> Factory[T]: ...
    @property
    def kwargs(self) -> dict[t.Any, Injection]: ...
    def add_kwargs(self, **kwargs: Injection) -> Factory[T]: ...
    def set_kwargs(self, **kwargs: Injection) -> Factory[T]: ...
    def clear_kwargs(self) -> Factory[T]: ...
    @property
    def attributes(self) -> dict[t.Any, Injection]: ...
    def add_attributes(self, **kwargs: Injection) -> Factory[T]: ...
    def set_attributes(self, **kwargs: Injection) -> Factory[T]: ...
    def clear_attributes(self) -> Factory[T]: ...

class DelegatedFactory(Factory[T]): ...

class AbstractFactory(Factory[T]):
    def override(self, provider: Factory) -> OverridingContext[P]: ...

class FactoryDelegate(Delegate):
    def __init__(self, factory: Factory): ...

class FactoryAggregate(Aggregate[T]):
    def __getattr__(self, provider_name: t.Any) -> Factory[T]: ...
    @property
    def factories(self) -> dict[t.Any, Factory[T]]: ...
    def set_factories(self, provider_dict: Optional[dict[t.Any, Factory[T]]] = None, **provider_kwargs: Factory[T]) -> FactoryAggregate[T]: ...

class BaseSingleton(Provider[T]):
    provided_type = Optional[Type]
    def __init__(self, provides: (t.Callable[..., T] | str) | None = None, *args: Injection, **kwargs: Injection) -> None: ...
    @property
    def cls(self) -> Type[T]: ...
    @property
    def provides(self) -> Optional[t.Callable[..., T]]: ...
    def set_provides(self, provides: (t.Callable[..., T] | str) | None) -> BaseSingleton[T]: ...
    @property
    def args(self) -> tuple[Injection]: ...
    def add_args(self, *args: Injection) -> BaseSingleton[T]: ...
    def set_args(self, *args: Injection) -> BaseSingleton[T]: ...
    def clear_args(self) -> BaseSingleton[T]: ...
    @property
    def kwargs(self) -> dict[t.Any, Injection]: ...
    def add_kwargs(self, **kwargs: Injection) -> BaseSingleton[T]: ...
    def set_kwargs(self, **kwargs: Injection) -> BaseSingleton[T]: ...
    def clear_kwargs(self) -> BaseSingleton[T]: ...
    @property
    def attributes(self) -> dict[t.Any, Injection]: ...
    def add_attributes(self, **kwargs: Injection) -> BaseSingleton[T]: ...
    def set_attributes(self, **kwargs: Injection) -> BaseSingleton[T]: ...
    def clear_attributes(self) -> BaseSingleton[T]: ...
    def reset(self) -> SingletonResetContext[BS]: ...
    def full_reset(self) -> SingletonFullResetContext[BS]: ...

class Singleton(BaseSingleton[T]): ...

class DelegatedSingleton(Singleton[T]): ...

class ThreadSafeSingleton(Singleton[T]): ...

class DelegatedThreadSafeSingleton(ThreadSafeSingleton[T]): ...

class ThreadLocalSingleton(BaseSingleton[T]): ...

class ContextLocalSingleton(BaseSingleton[T]): ...

class DelegatedThreadLocalSingleton(ThreadLocalSingleton[T]): ...

class AbstractSingleton(BaseSingleton[T]):
    def override(self, provider: BaseSingleton) -> OverridingContext[P]: ...

class SingletonDelegate(Delegate):
    def __init__(self, singleton: BaseSingleton): ...

class List(Provider[list]):
    def __init__(self, *args: Injection): ...
    @property
    def args(self) -> tuple[Injection]: ...
    def add_args(self, *args: Injection) -> List[T]: ...
    def set_args(self, *args: Injection) -> List[T]: ...
    def clear_args(self) -> List[T]: ...

class Dict(Provider[dict]):
    def __init__(self, dict_: Optional[dict[t.Any, Injection]] = None, **kwargs: Injection): ...
    @property
    def kwargs(self) -> dict[t.Any, Injection]: ...
    def add_kwargs(self, dict_: Optional[dict[t.Any, Injection]] = None, **kwargs: Injection) -> Dict: ...
    def set_kwargs(self, dict_: Optional[dict[t.Any, Injection]] = None, **kwargs: Injection) -> Dict: ...
    def clear_kwargs(self) -> Dict: ...

class Resource(Provider[T]):
    @t.overload
    def __init__(self, provides: Optional[Type[resources.Resource[T]]] = None, *args: Injection, **kwargs: Injection) -> None: ...   # noqa: E501
    @t.overload
    def __init__(self, provides: Optional[Type[resources.AsyncResource[T]]] = None, *args: Injection, **kwargs: Injection) -> None: ...  # noqa: E501
    @t.overload
    def __init__(self, provides: Optional[t.Callable[..., t.Iterator[T]]] = None, *args: Injection, **kwargs: Injection) -> None: ...  # noqa: E501
    @t.overload
    def __init__(self, provides: Optional[t.Callable[..., t.AsyncIterator[T]]] = None, *args: Injection, **kwargs: Injection) -> None: ...  # noqa: E501
    @t.overload
    def __init__(self, provides: Optional[t.Callable[..., t.Coroutine[Injection, Injection, T]]] = None, *args: Injection, **kwargs: Injection) -> None: ...  # noqa: E501
    @t.overload
    def __init__(self, provides: (t.Callable[..., T] | str) | None = None, *args: Injection, **kwargs: Injection) -> None: ...  # noqa: E501
    @property
    def provides(self) -> Optional[t.Callable[..., t.Any]]: ...
    def set_provides(self, provides: Optional[t.Any]) -> Resource[T]: ...
    @property
    def args(self) -> tuple[Injection]: ...
    def add_args(self, *args: Injection) -> Resource[T]: ...
    def set_args(self, *args: Injection) -> Resource[T]: ...
    def clear_args(self) -> Resource[T]: ...
    @property
    def kwargs(self) -> dict[t.Any, Injection]: ...
    def add_kwargs(self, **kwargs: Injection) -> Resource[T]: ...
    def set_kwargs(self, **kwargs: Injection) -> Resource[T]: ...
    def clear_kwargs(self) -> Resource[T]: ...
    @property
    def initialized(self) -> bool: ...
    def init(self) -> t.Awaitable[T] | None: ...
    def shutdown(self) -> t.Awaitable[t.Any] | None: ...

class Container(Provider[T]):
    def __init__(self, container_cls: Type[T], container: Optional[T] = None, **overriding_providers: Provider[T] | t.Any) -> None: ...  # noqa: E501
    def __getattr__(self, name: str) -> Provider[T]: ...
    @property
    def container(self) -> T: ...
    def resolve_provider_name(self, provider: Provider[T]) -> str: ...
    @property
    def parent(self) -> Optional[ProviderParent]: ...
    @property
    def parent_name(self) -> Optional[str]: ...
    def assign_parent(self, parent: ProviderParent) -> None: ...

class Selector(Provider[T]):
    def __init__(self, selector: t.Callable[..., T] | None = None, **providers: Provider[T]) -> None: ...
    def __getattr__(self, name: str) -> Provider[T]: ...

    @property
    def selector(self) -> t.Callable[..., T] | None: ...
    def set_selector(self, selector: Optional[t.Callable[..., t.Any]]) -> Selector[T]: ...

    @property
    def providers(self) -> dict[str, Provider[T]]: ...
    def set_providers(self, **providers: Provider[T]) -> Selector[T]: ...

class ProvidedInstanceFluentInterface:
    def __getattr__(self, item: t.Any) -> AttributeGetter: ...
    def __getitem__(self, item: t.Any) -> ItemGetter: ...
    def call(self, *args: Injection, **kwargs: Injection) -> MethodCaller: ...
    @property
    def provides(self) -> Optional[Provider]: ...
    def set_provides(self, provides: Optional[Provider]) -> ProvidedInstanceFluentInterface: ...

class ProvidedInstance(Provider, ProvidedInstanceFluentInterface):
    def __init__(self, provides: Optional[Provider] = None) -> None: ...

class AttributeGetter(Provider, ProvidedInstanceFluentInterface):
    def __init__(self, provides: Optional[Provider] = None, name: Optional[str] = None) -> None: ...
    @property
    def name(self) -> Optional[str]: ...
    def set_name(self, name: Optional[str]) -> ProvidedInstanceFluentInterface: ...

class ItemGetter(Provider, ProvidedInstanceFluentInterface):
    def __init__(self, provides: Optional[Provider] = None, name: Optional[str] = None) -> None: ...
    @property
    def name(self) -> Optional[str]: ...
    def set_name(self, name: Optional[str]) -> ProvidedInstanceFluentInterface: ...

class MethodCaller(Provider, ProvidedInstanceFluentInterface):
    def __init__(self, provides: Optional[Provider] = None, *args: Injection, **kwargs: Injection) -> None: ...

class OverridingContext(t.Generic[T]):
    def __init__(self, overridden: Provider, overriding: Provider): ...
    def __enter__(self) -> T: ...
    def __exit__(self, *_: t.Any) -> None:
        pass
    ...

class BaseSingletonResetContext(t.Generic[T]):
    def __init__(self, provider: T) -> None: ...
    def __enter__(self) -> T: ...
    def __exit__(self, *_: t.Any) -> None: ...

class SingletonResetContext(BaseSingletonResetContext):
    ...

class SingletonFullResetContext(BaseSingletonResetContext):
    ...

CHILD_PROVIDERS: tuple[Provider[t.Any]]

def is_provider(instance: t.Any) -> bool: ...
def ensure_is_provider(instance: t.Any) -> Provider[t.Any]: ...

def is_delegated(instance: t.Any) -> bool: ...

def represent_provider(provider: Provider[T], provides: T) -> str: ...

def deepcopy(instance: t.Any, memo: Optional[dict[t.Any, t.Any]] = None) -> t.Any: ...
def deepcopy_args(provider: Provider[t.Any], args: tuple[t.Any, ...], memo: Optional[dict[int, t.Any]] = None,) -> tuple[t.Any, ...]: ...
def deepcopy_kwargs(provider: Provider[t.Any], kwargs: dict[str, t.Any], memo: Optional[dict[int, t.Any]] = None) -> dict[str, t.Any]: ...  # noqa: E501

def merge_dicts(dict1: dict[t.Any, t.Any], dict2: dict[t.Any, t.Any]) -> dict[t.Any, t.Any]: ...
def traverse(*providers: Provider[T], types: Optional[t.Iterable[Type[T]]] = None) -> t.Iterator[Provider[T]]: ...

class YamlLoader(yaml.SafeLoader): ...
